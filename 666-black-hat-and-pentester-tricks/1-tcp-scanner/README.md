# Профилирование

## TCP-сканер портов
Реализации:
1) sync.WaitGroup
2) sync.WaitGroup + channels

### Команды
Если бы был main.go-файл, для начала можно было бы просто посмотреть результат команды:
```
go build -gcflags '-m' ./main.go
```
Займемся профайлингом.  
Профиль генерировать нужно отдельными командами, т.к. объектный файл .test создается с одним и тем же названием:
```
go test -bench=with_wg$ -cpu=8 -benchmem -cpuprofile=cpu_1.out -memprofile=mem_1.out .
go test -bench=with_wg_and_channels_test$ -cpu=8 -benchmem -cpuprofile=cpu_2.out -memprofile=mem_2.out .
```
Проверка CPU:
```
go tool pprof tcp-scanner.test cpu_1.out
```
Проверка памяти:
```
go tool pprof -alloc_objects mem_2.out  // кол-во аллоцированных объектов
go tool pprof -alloc_space mem_2.out    // кол-во выделенной памяти
```

### sync.WaitGroup

CPU:  
- 205.58ms  

Memory:  
- 902.59kB  

### sync.WaitGroup + channels

CPU:  
- 202.95ms   

Memory:
- 650.62kB

Пришлось оптимизировать выделение памяти для переменной address (было 2 136.21kB)
Код:
```go
// до
address := fmt.Sprintf("%s:%d", host, p)
conn, err := net.Dial("tcp", host+":"+strconv.Itoa(p))

// после
conn, err := net.Dial("tcp", host+":"+strconv.Itoa(p))
```

### Что не получилось
  
Заглянуть глубже функции [compress/flate.(*compressor).**init**] - ее выполнение занимает 100% (650.62kB).  
Это директива из стандартной библиотеки deflate.go [d.tokens = make([]token, maxStoreBlockSize)].  
Родительский вызов скорее всего типизированный массив с каналами [ports := make(chan int, maxPortNumber)].  

### Вывод

Ради экономии памяти на 30% пришлось пожертвовать простотой кода
