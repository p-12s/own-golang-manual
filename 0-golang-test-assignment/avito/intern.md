# Тестовое задание для заявки на стажировку в "Авито"

Приложение представляет из себя JSON API сервис для голосований.

Сервис обрабатывает запросы по следующим URL:
* **POST** `api/createPoll/` - создать голосование;
* **POST** `api/poll/<int:poll_id>/<int:choice_id>/` - проголосовать;
* **POST** `api/getResult/<int:poll_id>/` - получить результаты голосования.

## Использованные технологии
* **Python + Django** - я выбрал этот фреймворк, потому что мне хотелось построить API именно на нём. Для создания API я использую надстройки **Django REST Framework** (позволяет создать эндпоинты для API и удобно обрабатывать входные данные) и **Django REST Framework JSON API** (позволяет отправлять JSON, соответствующий [спецификации](https://jsonapi.org/))
* **PostgreSQL** в качестве базы данных
* **uWSGI** в качестве продакшен-сервера
* **nginx** в качетсве прокси-сервера, который является единственной входной точкой в сеть приложения.
* **Docker** и **docker-compose** для разворачивания приложения

## Архитектура приложения, его инфраструктура, список задач
Описано на платформе [Miro](https://miro.com/app/board/o9J_l7odgeg=/)

## Установка и запуск
1. Склонировать репозиторий
```
git clone https://github.com/r-egorov/avito-intern
```
2. В корневой директории в файл **.env** поместить свой секретный ключ для Django-приложений (можно не трогать)
3. При желании изменить имена пользователей и пароли в том же **.env**-файле.
4. Поднять сеть контейнеров с помощью docker-compose
```
docker-compose up [-d]
```
5. Для запуска unit-тестов можно воспользоваться командой
```
docker exec uwsgi-nginx sh -c "python manage.py test"
```

## Формат входных и выходных данных
<details>
  <summary>Спойлер</summary>

Формат входных и выходных данных выбран в соответствие [JSON API](https://jsonapi.org/):
### Запрос **POST** `api/createPoll/`

Во входных данных данного запроса должны быть следующие поля:

  ```
  {
      "data": {
        "question_text": "How do you do?",
        "choices": [
          {"choice_text": "Okay"},
          {"choice_text": "Fine"},
          {"choice_text": "Bad"},
          {"choice_text": "Don't know"}
       ]
    }
  }
  ```

В ответ на запрос будет отправлен следующий ответ со статусом `201 CREATED`, каждому варианту ответа будет присвоен ID внутри вопроса:
  ```
    {
        "data": {
            "type": "created_poll",
            "id": "1",
            "attributes": {
                "question_text": "How do you do?",
                "choices": [
                    {
                        "choice_id": 0,
                        "choice_text": "Okay"
                    },
                    {
                        "choice_id": 1,
                        "choice_text": "Fine"
                    },
                    {
                        "choice_id": 2,
                        "choice_text": "Bad"
                    },
                    {
                        "choice_id": 3,
                        "choice_text": "Don't know"
                    }
                ]
            }
        }
    }
  ```

При ошибке в полях входного запроса будет возвращены ошибки со статусом `400 BAD REQUEST`:
  ```
    {
        "errors": {
            "question_text": [
                "This field is required."
            ],
            "choices": [
                "This field is required."
            ]
        }
    }
  ```

### Запрос **POST** `api/poll/<int:poll_id>/<int:choice_id>/`

Я посчитал, что тело запроса можно оставить пустым, а номера голосования и варианта ответа передавать в URL.

`choice_id` - это внутренний (!) ID варианта ответа, он присваивается во время создания сущности вопроса. Таким образом, у вариантов ответа в каждом вопросе ID от 0 до (N - 1), где N - количество вариантов ответа.

В ответ на запрос будет отправлен следующий ответ со статусом `200 OK`:
  ```
  {
    "data": {
        "result": "OK"
    }
  }
  ```

При ошибке в номере голосования или варианта ответа будет отправлена ошибка со статусом 404 NOT FOUND:
  ```
  {
    "errors": [
        {
            "status": 404,
            "title": "Invalid Attribute",
            "detail": "No such poll"
        }
    ]
  }
  ```

### Запрос **POST** `api/getResult/<int:poll_id>/`

При ошибке в номере голосования будет отправлена ошибка 404 NOT FOUND.

При успешном выполнении запроса будет отправлен ответ с общим количеством голосов, количеством голосов. отданных за каждый вариант ответа, и процентом от общего количества голосов. Статус ответа 200 OK.
  ```
  {
    "data": {
        "type": "poll_result",
        "id": "1",
        "attributes": {
            "question_text": "What would you like to eat?",
            "total_votes": 5,
            "choices": [
                {
                    "choice_id": 0,
                    "choice_text": "Banana",
                    "num_votes": 4,
                    "percentage": 80
                },
                {
                    "choice_id": 1,
                    "choice_text": "Apple",
                    "num_votes": 0,
                    "percentage": 0
                },
                {
                    "choice_id": 2,
                    "choice_text": "Eggs",
                    "num_votes": 0,
                    "percentage": 0
                },
                {
                    "choice_id": 3,
                    "choice_text": "Not hungry",
                    "num_votes": 1,
                    "percentage": 20
                }
            ]
        }
    }
  }
```
  </details>


</details>

## Как изменится архитектура при больших нагрузках?
Для начала, можно увеличить количество рабочих процессов **uWSGI**.
**uWSGI** - это синхронный сервер, для увеличения проходной способности можно перейти на асинхронный протокол **ASGI**.

**Django** - синхронный фреймворк. Для использования многопоточности можно перейти на асинхронный фремворк вроде **Tornado**.

## Как защититься от накруток?
На данный момент мой сервис не поддерживает регистрацию пользователей. Добавив авторизацию, мы сможем помещать в сущность Ответа на голосование (модель **Answer**) данные о пользователе. Таким образом, мы сделаем каждый голос уникальным.

Если мы рассмотрим накрутку как многократное голосование разных пользователей за один вариант ответа за короткое время, то можно определить лимит количества голосов за единицу времени и вызывать таймаут при превышении лимита.


## Дерево проекта
```
.
├── db
│   └── scripts
│       └── 01-init.sh
├── docker-compose.yml
└── polls
    ├── Dockerfile
    ├── manage.py
    ├── polls
    │   ├── __init__.py
    │   ├── api
    │   │   ├── __init__.py
    │   │   ├── admin.py
    │   │   ├── apps.py
    │   │   ├── error_rendering.py
    │   │   ├── migrations
    │   │   ├── models.py
    │   │   ├── serializers.py
    │   │   ├── tests
    │   │   └── views.py
    │   ├── asgi.py
    │   ├── settings.py
    │   ├── urls.py
    │   └── wsgi.py
    ├── requirements.txt
    └── uwsgi.ini
```

## Сложности, возникшие при выполнении задания

* Вложенная сериализация. Сериализатор голосования включает в себя сериализатор вариантов ответа. Решение я нашёл в документации **Django REST Framework**
* Развёртывание приложения. Я использую готовое решение для контейнеризации **uWSGI+nginx**, в котором **uWSGI** отказывался слушать сокет, по которому **nginx** передавал запросы

## PS
Спасибо за интересное задание и проект в портфолио!